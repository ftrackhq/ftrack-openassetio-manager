
"""
Trait definitions in the 'core' namespace.

Core traits.
"""

# WARNING: This file is auto-generated by openassetio-traitgen, do not edit.

from typing import Union

from openassetio.trait import TraitsData


class AssetVersionTrait:
    """
    AssetVersion traits.
    Usage: entity
    """
    kId = "ftrack_traits:core.AssetVersion"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setId(self, id: str):
        """
        Sets the id property.

        unique identifier.
        """
        if not isinstance(id, str):
            raise TypeError("id must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "id", id)

    def getId(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the id property or the supplied default.

        unique identifier.
        """
        value = self.__data.getTraitProperty(self.kId, "id")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setLatest(self, latest: bool):
        """
        Sets the latest property.

        Whether the version is the latest published.
        """
        if not isinstance(latest, bool):
            raise TypeError("latest must be a 'bool'.")
        self.__data.setTraitProperty(self.kId, "latest", latest)

    def getLatest(self, defaultValue: bool=None) -> Union[bool, None]:
        """
        Gets the value of the latest property or the supplied default.

        Whether the version is the latest published.
        """
        value = self.__data.getTraitProperty(self.kId, "latest")
        if value is None:
            return defaultValue

        if not isinstance(value, bool):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'bool'.")
            return defaultValue
        return value
        
    def setVersion(self, version: int):
        """
        Sets the version property.

        Version of the entity.
        """
        if not isinstance(version, int):
            raise TypeError("version must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "version", version)

    def getVersion(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the version property or the supplied default.

        Version of the entity.
        """
        value = self.__data.getTraitProperty(self.kId, "version")
        if value is None:
            return defaultValue

        if not isinstance(value, int):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    


class ComponentTrait:
    """
    Component traits.
    Usage: entity
    """
    kId = "ftrack_traits:core.Component"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setAnme(self, anme: str):
        """
        Sets the anme property.

        name of the component.
        """
        if not isinstance(anme, str):
            raise TypeError("anme must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "anme", anme)

    def getAnme(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the anme property or the supplied default.

        name of the component.
        """
        value = self.__data.getTraitProperty(self.kId, "anme")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setFilePath(self, filePath: str):
        """
        Sets the filePath property.

        path of the component.
        """
        if not isinstance(filePath, str):
            raise TypeError("filePath must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "filePath", filePath)

    def getFilePath(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the filePath property or the supplied default.

        path of the component.
        """
        value = self.__data.getTraitProperty(self.kId, "filePath")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setId(self, id: str):
        """
        Sets the id property.

        unique identifier.
        """
        if not isinstance(id, str):
            raise TypeError("id must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "id", id)

    def getId(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the id property or the supplied default.

        unique identifier.
        """
        value = self.__data.getTraitProperty(self.kId, "id")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setUrl(self, url: str):
        """
        Sets the url property.

        url of the component.
        """
        if not isinstance(url, str):
            raise TypeError("url must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "url", url)

    def getUrl(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the url property or the supplied default.

        url of the component.
        """
        value = self.__data.getTraitProperty(self.kId, "url")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    


class LocationTrait:
    """
    Location traits.
    Usage: entity
    """
    kId = "ftrack_traits:core.Location"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setId(self, id: str):
        """
        Sets the id property.

        unique identifier.
        """
        if not isinstance(id, str):
            raise TypeError("id must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "id", id)

    def getId(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the id property or the supplied default.

        unique identifier.
        """
        value = self.__data.getTraitProperty(self.kId, "id")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setName(self, name: str):
        """
        Sets the name property.

        name of the location.
        """
        if not isinstance(name, str):
            raise TypeError("name must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "name", name)

    def getName(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the name property or the supplied default.

        name of the location.
        """
        value = self.__data.getTraitProperty(self.kId, "name")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    


class ProjectTrait:
    """
    Project traits.
    Usage: entity
    """
    kId = "ftrack_traits:core.Project"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setActive(self, active: bool):
        """
        Sets the active property.

        whether the project is active.
        """
        if not isinstance(active, bool):
            raise TypeError("active must be a 'bool'.")
        self.__data.setTraitProperty(self.kId, "active", active)

    def getActive(self, defaultValue: bool=None) -> Union[bool, None]:
        """
        Gets the value of the active property or the supplied default.

        whether the project is active.
        """
        value = self.__data.getTraitProperty(self.kId, "active")
        if value is None:
            return defaultValue

        if not isinstance(value, bool):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'bool'.")
            return defaultValue
        return value
        
    def setCode(self, code: str):
        """
        Sets the code property.

        Code of the project.
        """
        if not isinstance(code, str):
            raise TypeError("code must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "code", code)

    def getCode(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the code property or the supplied default.

        Code of the project.
        """
        value = self.__data.getTraitProperty(self.kId, "code")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setId(self, id: str):
        """
        Sets the id property.

        unique identifier.
        """
        if not isinstance(id, str):
            raise TypeError("id must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "id", id)

    def getId(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the id property or the supplied default.

        unique identifier.
        """
        value = self.__data.getTraitProperty(self.kId, "id")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setName(self, name: str):
        """
        Sets the name property.

        Name of the project.
        """
        if not isinstance(name, str):
            raise TypeError("name must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "name", name)

    def getName(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the name property or the supplied default.

        Name of the project.
        """
        value = self.__data.getTraitProperty(self.kId, "name")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    


class TypedContextTrait:
    """
    Context traits.
    Usage: entity
    """
    kId = "ftrack_traits:core.TypedContext"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setId(self, id: str):
        """
        Sets the id property.

        unique identifier.
        """
        if not isinstance(id, str):
            raise TypeError("id must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "id", id)

    def getId(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the id property or the supplied default.

        unique identifier.
        """
        value = self.__data.getTraitProperty(self.kId, "id")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setName(self, name: str):
        """
        Sets the name property.

        Name of the context.
        """
        if not isinstance(name, str):
            raise TypeError("name must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "name", name)

    def getName(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the name property or the supplied default.

        Name of the context.
        """
        value = self.__data.getTraitProperty(self.kId, "name")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    def setType(self, type: str):
        """
        Sets the type property.

        Type of the context.
        """
        if not isinstance(type, str):
            raise TypeError("type must be a 'str'.")
        self.__data.setTraitProperty(self.kId, "type", type)

    def getType(self, defaultValue: str=None) -> Union[str, None]:
        """
        Gets the value of the type property or the supplied default.

        Type of the context.
        """
        value = self.__data.getTraitProperty(self.kId, "type")
        if value is None:
            return defaultValue

        if not isinstance(value, str):
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'str'.")
            return defaultValue
        return value
        
    

